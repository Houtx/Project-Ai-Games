<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªåŠ¨å¯»è·¯è´ªåƒè›‡ - AI Snake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            padding: 20px;
        }

        .container {
            background: rgba(26, 26, 46, 0.8);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 20px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(0, 255, 136, 0.3);
            flex: 1;
        }

        .info-label {
            font-size: 0.9em;
            color: #888;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 2em;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #gameCanvas {
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            display: block;
            margin: 0 auto 20px;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        button {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startBtn {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
        }

        #startBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        #resetBtn {
            background: linear-gradient(45deg, #ff3366, #ff6699);
            color: #fff;
        }

        #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 51, 102, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .legend {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 0.85em;
            color: #aaa;
        }

        .legend-item {
            display: inline-block;
            margin: 0 15px;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ è‡ªåŠ¨å¯»è·¯è´ªåƒè›‡</h1>

        <div class="info-panel">
            <div class="info-box">
                <div class="info-label">å½“å‰å¾—åˆ†</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">æœ€é«˜åˆ†</div>
                <div class="info-value" id="highScore">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">ç¢°æ’é£é™©</div>
                <div class="info-value" id="collisionRisk" style="font-size: 1.5em;">0%</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div class="controls">
            <button id="startBtn">å¼€å§‹æ¸¸æˆ</button>
            <button id="resetBtn">é‡ç½®æ¸¸æˆ</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background: #00ff88;"></span>
                è›‡å¤´
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #00cc66;"></span>
                è›‡èº«
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #ff3366;"></span>
                é£Ÿç‰©
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: rgba(0, 255, 255, 0.3); border: 1px solid #0ff;"></span>
                è§„åˆ’è·¯å¾„
            </div>
        </div>

        <div class="footer">
            AI è‡ªåŠ¨å¯»è·¯ | BFS ç®—æ³• | è·¯å¾„å¯è§†åŒ– | å®æ—¶é£é™©è¯„ä¼°
        </div>
    </div>

    <script>
        // =================================================================
        // æ¸¸æˆé…ç½®
        // =================================================================
        const CONFIG = {
            GRID_SIZE: 20,           // æ¯ä¸ªæ ¼å­çš„åƒç´ å¤§å°
            COLS: 30,                // åˆ—æ•°
            ROWS: 20,                // è¡Œæ•°
            TICK_RATE: 120,          // æ¸¸æˆé€Ÿåº¦ï¼ˆæ¯«ç§’ï¼‰
            INITIAL_LENGTH: 3        // åˆå§‹è›‡é•¿åº¦
        };

        // =================================================================
        // æ¸¸æˆçŠ¶æ€
        // =================================================================
        let canvas, ctx;
        let gameState = 'stopped'; // 'stopped', 'running', 'paused'
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoop = null;

        // è›‡çš„æ•°æ®ç»“æ„
        let snake = {
            body: [],         // [{x, y}, ...]
            direction: { x: 1, y: 0 }
        };

        // é£Ÿç‰©ä½ç½®
        let food = { x: 0, y: 0 };

        // å½“å‰è§„åˆ’çš„è·¯å¾„ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰
        let currentPath = [];

        // åƒé£Ÿç‰©åçš„ç¼“å†²æ­¥æ•°ï¼ˆç”¨äºä¼˜åŒ–ç®—æ³•ï¼‰
        let stepsAfterEating = 0;
        const BUFFER_STEPS = 5; // åƒé£Ÿç‰©åç¼“å†²çš„æ­¥æ•°

        // =================================================================
        // åˆå§‹åŒ–
        // =================================================================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // æ›´æ–°æœ€é«˜åˆ†æ˜¾ç¤º
            document.getElementById('highScore').textContent = highScore;

            // æŒ‰é’®äº‹ä»¶
            document.getElementById('startBtn').addEventListener('click', toggleGame);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // åˆå§‹åŒ–æ¸¸æˆ
            resetGame();
        }

        // =================================================================
        // æ¸¸æˆæ§åˆ¶
        // =================================================================
        function toggleGame() {
            const btn = document.getElementById('startBtn');

            if (gameState === 'stopped' || gameState === 'paused') {
                gameState = 'running';
                btn.textContent = 'æš‚åœæ¸¸æˆ';
                startGameLoop();
            } else if (gameState === 'running') {
                gameState = 'paused';
                btn.textContent = 'ç»§ç»­æ¸¸æˆ';
                stopGameLoop();
            }
        }

        function resetGame() {
            stopGameLoop();
            gameState = 'stopped';
            score = 0;
            document.getElementById('score').textContent = score;
            document.getElementById('startBtn').textContent = 'å¼€å§‹æ¸¸æˆ';

            // åˆå§‹åŒ–è›‡ï¼ˆä»ä¸­é—´å¼€å§‹,å‘å³ç§»åŠ¨ï¼‰
            const startX = Math.floor(CONFIG.COLS / 4);
            const startY = Math.floor(CONFIG.ROWS / 2);

            snake.body = [];
            for (let i = 0; i < CONFIG.INITIAL_LENGTH; i++) {
                snake.body.push({ x: startX - i, y: startY });
            }
            snake.direction = { x: 1, y: 0 };

            // ç”Ÿæˆé£Ÿç‰©
            generateFood();

            // æ¸…ç©ºè·¯å¾„
            currentPath = [];
            stepsAfterEating = BUFFER_STEPS; // åˆå§‹æ—¶ä¸å¼ºåˆ¶ç¼“å†²

            // æ¸²æŸ“åˆå§‹çŠ¶æ€
            render();

            // æ›´æ–°ç¢°æ’é£é™©æ˜¾ç¤º
            updateCollisionRiskDisplay();
        }

        function startGameLoop() {
            if (gameLoop) return;
            gameLoop = setInterval(update, CONFIG.TICK_RATE);
        }

        function stopGameLoop() {
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
        }

        // =================================================================
        // æ¸¸æˆä¸»å¾ªç¯
        // =================================================================
        function update() {
            // ä½¿ç”¨ AI è®¡ç®—ä¸‹ä¸€æ­¥æ–¹å‘
            const nextDirection = calculateNextMove();

            if (nextDirection) {
                snake.direction = nextDirection;
            }

            // è®¡ç®—æ–°çš„è›‡å¤´ä½ç½®
            const head = snake.body[0];
            const newHead = {
                x: head.x + snake.direction.x,
                y: head.y + snake.direction.y
            };

            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©ï¼ˆæå‰æ£€æŸ¥ä»¥å†³å®šç¢°æ’é€»è¾‘ï¼‰
            const willEat = (newHead.x === food.x && newHead.y === food.y);

            // æ£€æµ‹ç¢°æ’
            // å¦‚æœä¸åƒé£Ÿç‰©,å°¾å·´ä¼šç§»èµ°,æ‰€ä»¥ç¢°æ’æ£€æµ‹æ—¶å¯ä»¥å¿½ç•¥å½“å‰å°¾å·´ä½ç½®
            if (checkCollision(newHead, !willEat)) {
                gameOver();
                return;
            }

            // ç§»åŠ¨è›‡
            snake.body.unshift(newHead);

            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            if (willEat) {
                score++;
                document.getElementById('score').textContent = score;

                // æ›´æ–°æœ€é«˜åˆ†
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('snakeHighScore', highScore);
                    document.getElementById('highScore').textContent = highScore;
                }

                generateFood();
                // é‡ç½®ç¼“å†²æ­¥æ•°,å¼€å§‹ç¼“å†²æœŸ
                stepsAfterEating = 0;
            } else {
                // æ²¡åƒåˆ°é£Ÿç‰©,ç§»é™¤å°¾å·´
                snake.body.pop();
                // å¢åŠ ç¼“å†²æ­¥æ•°
                if (stepsAfterEating < BUFFER_STEPS) {
                    stepsAfterEating++;
                }
            }

            // æ›´æ–°ç¢°æ’é£é™©æ˜¾ç¤º
            updateCollisionRiskDisplay();

            // æ¸²æŸ“
            render();
        }

        // =================================================================
        // AI å¯»è·¯ç®—æ³•æ ¸å¿ƒ
        // =================================================================
        function calculateNextMove() {
            const head = snake.body[0];
            const obstacles = getObstacles();

            // 0. ç¼“å†²æœŸæˆ–é£é™©è§„é¿
            // å¦‚æœåˆšåƒå®Œé£Ÿç‰©ï¼ˆç¼“å†²æœŸï¼‰,æˆ–è€…å¤„äºå±é™©çŠ¶æ€,ä¼˜å…ˆå¾€ç©ºæ—·åœ°æ–¹èµ°
            let isRisky = false;

            // ç®€å•çš„é£é™©æ£€æµ‹:å¦‚æœå‘¨å›´å¯ç”¨ç©ºé—´å¾ˆå°‘
            const availableSpaces = getAvailableSpacesAround(head, obstacles);
            // å¦‚æœåªæœ‰1ä¸ªæˆ–æ›´å°‘çš„æ–¹å‘å¯èµ°,ä¸”è›‡èº«è¾ƒé•¿,è®¤ä¸ºæœ‰é£é™©
            if (availableSpaces <= 1 && snake.body.length > 5) {
                isRisky = true;
            }

            // å¦‚æœåœ¨ç¼“å†²æœŸæˆ–è€…æœ‰é£é™©,ä¼˜å…ˆå¯»æ‰¾æœ€å¤§ç©ºé—´
            if (stepsAfterEating < BUFFER_STEPS || isRisky) {
                const bestDir = findLongestPath(head);
                if (bestDir) {
                    // ç®€å•éªŒè¯ä¸€ä¸‹è¿™ä¸ªæ–¹å‘æ˜¯å¦å®‰å…¨
                    const nextPos = { x: head.x + bestDir.x, y: head.y + bestDir.y };
                    // æ£€æŸ¥ç¢°æ’æ—¶,å‡è®¾ä¸åƒé£Ÿç‰©ï¼ˆé™¤éæ­£å¥½æ’ä¸Šé£Ÿç‰©,é‚£æ›´å¥½ï¼‰
                    const isFood = (nextPos.x === food.x && nextPos.y === food.y);
                    if (!checkCollision(nextPos, !isFood)) {
                        currentPath = []; // æ¸…é™¤è·¯å¾„æ˜¾ç¤º
                        return bestDir;
                    }
                }
            }

            // 1. é¦–å…ˆå°è¯•æ‰¾åˆ°ä¸€æ¡å®‰å…¨çš„è·¯å¾„åˆ°é£Ÿç‰©
            const pathToFood = findSafePath(head, food);

            if (pathToFood && pathToFood.length > 1) {
                currentPath = pathToFood;
                const nextPos = pathToFood[1];
                return {
                    x: nextPos.x - head.x,
                    y: nextPos.y - head.y
                };
            }

            // 2. å¦‚æœæ²¡æœ‰å®‰å…¨è·¯å¾„åˆ°é£Ÿç‰©,å°è¯•è¿½ç€å°¾å·´è·‘
            const tail = snake.body[snake.body.length - 1];
            const pathToTail = findPathBFS(head, tail, obstacles);

            if (pathToTail && pathToTail.length > 1) {
                currentPath = pathToTail;
                const nextPos = pathToTail[1];
                return {
                    x: nextPos.x - head.x,
                    y: nextPos.y - head.y
                };
            }

            // 3. å¦‚æœè¿å°¾å·´éƒ½è¿½ä¸åˆ°,æ‰¾ä¸€ä¸ªæœ€é•¿çš„è·¯å¾„ï¼ˆé¿å…æ­»è·¯ï¼‰
            const longestDir = findLongestPath(head);
            if (longestDir) {
                currentPath = [];
                return longestDir;
            }

            // 4. å®åœ¨æ²¡åŠæ³•,éšä¾¿æ‰¾ä¸€ä¸ªä¸ä¼šç«‹å³æ­»äº¡çš„æ–¹å‘
            const directions = [
                { x: 0, y: -1 }, // ä¸Š
                { x: 1, y: 0 },  // å³
                { x: 0, y: 1 },  // ä¸‹
                { x: -1, y: 0 }  // å·¦
            ];

            for (const dir of directions) {
                const nextPos = {
                    x: head.x + dir.x,
                    y: head.y + dir.y
                };
                if (!checkCollision(nextPos, true)) {
                    currentPath = [];
                    return dir;
                }
            }

            // çœŸçš„æ— è·¯å¯èµ°äº†
            return snake.direction;
        }

        // =================================================================
        // ç¢°æ’æ£€æµ‹
        // =================================================================
        function checkCollision(pos, ignoreTail = false) {
            // æ£€æŸ¥æ˜¯å¦æ’å¢™
            if (pos.x < 0 || pos.x >= CONFIG.COLS ||
                pos.y < 0 || pos.y >= CONFIG.ROWS) {
                return true;
            }

            // æ£€æŸ¥æ˜¯å¦æ’åˆ°è‡ªå·±
            // å¦‚æœ ignoreTail ä¸º true,åˆ™ä¸æ£€æŸ¥æœ€åä¸€ä¸ªèº«ä½“æ®µï¼ˆå› ä¸ºç§»åŠ¨åå®ƒä¼šæ¶ˆå¤±ï¼‰
            const len = ignoreTail ? snake.body.length - 1 : snake.body.length;
            for (let i = 0; i < len; i++) {
                if (pos.x === snake.body[i].x && pos.y === snake.body[i].y) {
                    return true;
                }
            }

            return false;
        }

        // =================================================================
        // ç¢°æ’æ¦‚ç‡è®¡ç®—
        // =================================================================
        function calculateCollisionRisk() {
            const head = snake.body[0];
            const obstacles = getObstacles();

            // è®¡ç®—å››ä¸ªæ–¹å‘çš„å¯ç”¨æ€§
            const directions = [
                { x: 0, y: -1 }, // ä¸Š
                { x: 1, y: 0 },  // å³
                { x: 0, y: 1 },  // ä¸‹
                { x: -1, y: 0 }  // å·¦
            ];

            let blockedDirections = 0;
            let nearWallCount = 0;
            let nearBodyCount = 0;

            // æ£€æŸ¥æ¯ä¸ªæ–¹å‘
            for (const dir of directions) {
                const nextPos = {
                    x: head.x + dir.x,
                    y: head.y + dir.y
                };

                // æ£€æŸ¥æ˜¯å¦æ’å¢™
                if (nextPos.x < 0 || nextPos.x >= CONFIG.COLS ||
                    nextPos.y < 0 || nextPos.y >= CONFIG.ROWS) {
                    blockedDirections++;
                    nearWallCount++;
                    continue;
                }

                // æ£€æŸ¥æ˜¯å¦æ’åˆ°èº«ä½“
                if (obstacles.has(`${nextPos.x},${nextPos.y}`)) {
                    blockedDirections++;
                    nearBodyCount++;
                }
            }

            // è®¡ç®—å¯è¾¾ç©ºé—´
            const reachableSpaces = countReachableSpaces(head);
            const maxSpaces = CONFIG.COLS * CONFIG.ROWS;
            const spaceRatio = reachableSpaces / maxSpaces;

            // ç»¼åˆè®¡ç®—é£é™©å€¼
            let risk = 0;

            // 1. è¢«é˜»æŒ¡æ–¹å‘çš„å½±å“ (0-40åˆ†)
            risk += (blockedDirections / 4) * 40;

            // 2. å¯è¾¾ç©ºé—´çš„å½±å“ (0-30åˆ†)
            risk += (1 - spaceRatio) * 30;

            // 3. è›‡èº«é•¿åº¦çš„å½±å“ (0-20åˆ†)
            const lengthRatio = snake.body.length / (CONFIG.COLS * CONFIG.ROWS);
            risk += lengthRatio * 20;

            // 4. é è¿‘å¢™å£çš„å½±å“ (0-10åˆ†)
            risk += (nearWallCount / 4) * 10;

            // ç¡®ä¿é£é™©å€¼åœ¨0-100ä¹‹é—´
            risk = Math.min(100, Math.max(0, risk));

            return Math.round(risk);
        }

        function updateCollisionRiskDisplay() {
            const risk = calculateCollisionRisk();
            const riskElement = document.getElementById('collisionRisk');
            riskElement.textContent = risk + '%';

            // æ ¹æ®é£é™©ç­‰çº§æ”¹å˜é¢œè‰²
            if (risk < 30) {
                riskElement.style.color = '#00ff88'; // ç»¿è‰² - å®‰å…¨
                riskElement.style.textShadow = '0 0 10px rgba(0, 255, 136, 0.5)';
            } else if (risk < 60) {
                riskElement.style.color = '#ffaa00'; // æ©™è‰² - è­¦å‘Š
                riskElement.style.textShadow = '0 0 10px rgba(255, 170, 0, 0.5)';
            } else {
                riskElement.style.color = '#ff3366'; // çº¢è‰² - å±é™©
                riskElement.style.textShadow = '0 0 10px rgba(255, 51, 102, 0.5)';
            }

            // æ·»åŠ è„‰å†²åŠ¨ç”»æ•ˆæœ(é«˜é£é™©æ—¶)
            if (risk >= 70) {
                riskElement.style.animation = 'pulse 0.5s ease-in-out infinite';
            } else {
                riskElement.style.animation = 'none';
            }
        }

        // =================================================================
        // å¯»è·¯è¾…åŠ©å‡½æ•°
        // =================================================================
        function getObstacles() {
            const obstacles = new Set();

            // è›‡èº«ä½œä¸ºéšœç¢ç‰©ï¼ˆä¸åŒ…æ‹¬å°¾å·´,å› ä¸ºä¸‹ä¸€æ­¥å°¾å·´ä¼šç§»åŠ¨ï¼‰
            for (let i = 0; i < snake.body.length - 1; i++) {
                const segment = snake.body[i];
                obstacles.add(`${segment.x},${segment.y}`);
            }

            return obstacles;
        }

        function findPathBFS(start, target, obstacles) {
            const queue = [[start]];
            const visited = new Set();
            visited.add(`${start.x},${start.y}`);

            const directions = [
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: -1, y: 0 }
            ];

            while (queue.length > 0) {
                const path = queue.shift();
                const current = path[path.length - 1];

                if (current.x === target.x && current.y === target.y) {
                    return path;
                }

                for (const dir of directions) {
                    const next = {
                        x: current.x + dir.x,
                        y: current.y + dir.y
                    };

                    const key = `${next.x},${next.y}`;

                    if (next.x < 0 || next.x >= CONFIG.COLS ||
                        next.y < 0 || next.y >= CONFIG.ROWS) {
                        continue;
                    }

                    if (visited.has(key) || obstacles.has(key)) {
                        continue;
                    }

                    visited.add(key);
                    queue.push([...path, next]);
                }
            }

            return null;
        }

        function findSafePath(start, target) {
            const obstacles = getObstacles();
            const path = findPathBFS(start, target, obstacles);

            if (!path) return null;

            // æ¨¡æ‹Ÿèµ°è¿™æ¡è·¯å¾„å,è›‡èƒ½å¦ç»§ç»­æ‰¾åˆ°å°¾å·´
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®‰å…¨æ€§æ£€æŸ¥
            const simulatedSnake = snake.body.map(seg => ({ ...seg }));

            for (let i = 1; i < path.length; i++) {
                simulatedSnake.unshift({ ...path[i] });
                if (i < path.length - 1) {
                    simulatedSnake.pop();
                }
            }

            // æ£€æŸ¥åˆ°è¾¾é£Ÿç‰©å,èƒ½å¦æ‰¾åˆ°å°¾å·´
            const newObstacles = new Set();
            for (let i = 0; i < simulatedSnake.length - 1; i++) {
                newObstacles.add(`${simulatedSnake[i].x},${simulatedSnake[i].y}`);
            }

            const tail = simulatedSnake[simulatedSnake.length - 1];
            const pathToTail = findPathBFS(simulatedSnake[0], tail, newObstacles);

            return pathToTail ? path : null;
        }

        function findLongestPath(start) {
            const directions = [
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: -1, y: 0 }
            ];

            let bestDir = null;
            let maxSpaces = -1;

            for (const dir of directions) {
                const next = {
                    x: start.x + dir.x,
                    y: start.y + dir.y
                };

                if (checkCollision(next, true)) {
                    continue;
                }

                const spaces = countReachableSpaces(next);
                if (spaces > maxSpaces) {
                    maxSpaces = spaces;
                    bestDir = dir;
                }
            }

            return bestDir;
        }

        function countReachableSpaces(start) {
            const obstacles = getObstacles();
            const visited = new Set();
            const queue = [start];
            visited.add(`${start.x},${start.y}`);

            const directions = [
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: -1, y: 0 }
            ];

            let count = 0;
            const maxSteps = 20; // é™åˆ¶æœç´¢æ·±åº¦

            while (queue.length > 0 && count < maxSteps) {
                const current = queue.shift();
                count++;

                for (const dir of directions) {
                    const next = {
                        x: current.x + dir.x,
                        y: current.y + dir.y
                    };

                    const key = `${next.x},${next.y}`;

                    if (next.x < 0 || next.x >= CONFIG.COLS ||
                        next.y < 0 || next.y >= CONFIG.ROWS) {
                        continue;
                    }

                    if (visited.has(key) || obstacles.has(key)) {
                        continue;
                    }

                    visited.add(key);
                    queue.push(next);
                }
            }

            return count;
        }

        function getAvailableSpacesAround(pos, obstacles) {
            const directions = [
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: -1, y: 0 }
            ];

            let count = 0;
            for (const dir of directions) {
                const next = {
                    x: pos.x + dir.x,
                    y: pos.y + dir.y
                };

                if (next.x >= 0 && next.x < CONFIG.COLS &&
                    next.y >= 0 && next.y < CONFIG.ROWS &&
                    !obstacles.has(`${next.x},${next.y}`)) {
                    count++;
                }
            }

            return count;
        }

        // =================================================================
        // é£Ÿç‰©ç”Ÿæˆ
        // =================================================================
        function generateFood() {
            const occupiedPositions = new Set();
            snake.body.forEach(segment => {
                occupiedPositions.add(`${segment.x},${segment.y}`);
            });

            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * CONFIG.COLS),
                    y: Math.floor(Math.random() * CONFIG.ROWS)
                };
            } while (occupiedPositions.has(`${newFood.x},${newFood.y}`));

            food = newFood;
        }

        // =================================================================
        // æ¸¸æˆç»“æŸ
        // =================================================================
        function gameOver() {
            stopGameLoop();
            gameState = 'stopped';
            document.getElementById('startBtn').textContent = 'é‡æ–°å¼€å§‹';

            // åœ¨ç”»å¸ƒä¸Šæ˜¾ç¤ºæ¸¸æˆç»“æŸ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff3366';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 30);

            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`å¾—åˆ†: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        }

        // =================================================================
        // æ¸²æŸ“
        // =================================================================
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼ï¼ˆå¯é€‰ï¼‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CONFIG.COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CONFIG.GRID_SIZE, 0);
                ctx.lineTo(i * CONFIG.GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= CONFIG.ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * CONFIG.GRID_SIZE);
                ctx.lineTo(canvas.width, i * CONFIG.GRID_SIZE);
                ctx.stroke();
            }

            // ç»˜åˆ¶è§„åˆ’è·¯å¾„
            if (currentPath.length > 1) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(
                    currentPath[0].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2,
                    currentPath[0].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2
                );
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(
                        currentPath[i].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2,
                        currentPath[i].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2
                    );
                }
                ctx.stroke();
            }

            // ç»˜åˆ¶é£Ÿç‰©
            ctx.fillStyle = '#ff3366';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff3366';
            drawRoundedRect(
                food.x * CONFIG.GRID_SIZE + 2,
                food.y * CONFIG.GRID_SIZE + 2,
                CONFIG.GRID_SIZE - 4,
                CONFIG.GRID_SIZE - 4,
                5
            );
            ctx.fill();
            ctx.shadowBlur = 0;

            // ç»˜åˆ¶è›‡
            snake.body.forEach((segment, index) => {
                if (index === 0) {
                    // è›‡å¤´
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff88';
                } else {
                    // è›‡èº«
                    ctx.fillStyle = '#00cc66';
                    ctx.shadowBlur = 0;
                }

                drawRoundedRect(
                    segment.x * CONFIG.GRID_SIZE + 1,
                    segment.y * CONFIG.GRID_SIZE + 1,
                    CONFIG.GRID_SIZE - 2,
                    CONFIG.GRID_SIZE - 2,
                    4
                );
                ctx.fill();
            });

            ctx.shadowBlur = 0;
        }

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // =================================================================
        // å¯åŠ¨æ¸¸æˆ
        // =================================================================
        window.addEventListener('load', init);
    </script>
</body>

</html>